/* fs.c - File system wrappers for RISC OS SWIs (libOS) */

#include "common.h"
#include "fs.h"
#include "fcntl.h" // O_RDONLY, etc.

#include <stdlib.h>
#include <string.h>

// ----------------------------
// File and Directory Operations
// ----------------------------

int os_mkdir(const char *path, int mode) {
    (void)mode;
    if (!path || *path == '\0') {
        errno = EINVAL;
        return -1;
    }

    const _kernel_oserror *err = _swix(OS_File, _INR(0,1), 8, path);  // Create directory
    if (err) {
        errno = os_map_error(err->errnum);
        return -1;
    }
    return 0;
}

int os_rmdir(const char *path) {
    if (!path || *path == '\0') {
        errno = EINVAL;
        return -1;
    }

    os_stat_t st;
    if (os_stat(path, &st) < 0)
        return -1;

    if ((st.st_mode & 0xF000) != 0x4000) { // Not a directory
        errno = ENOTDIR;
        return -1;
    }

    // Use OS_FSControl 27 with force bit set, no recurse
    int flags = 0; 
    flags |= 0x00000001; // Force delete


    const _kernel_oserror *err = _swix(OS_FSControl, _INR(0,7),
                                       27, path, flags, -1, -1, -1, -1);

    if (err) {
        errno = os_map_error(err->errnum);
        return -1;
    }

    return 0;
}



int os_chdir(const char *path) {
    if (!path || *path == '\0') {
        errno = EINVAL;
        return -1;
    }

    const _kernel_oserror *err = _swix(OS_FSControl, _INR(0,1), 0, path); // Set current dir
    if (err) {
        errno = os_map_error(err->errnum);
        return -1;
    }
    return 0;
}

char *os_getcwd(char *buf, size_t size) {
    if (!buf || size == 0) {
        errno = EINVAL;
        return NULL;
    }

    const char *var = "@"; // read @
    int spare = 0;

    const _kernel_oserror *err = _swix(OS_FSControl,
        _INR(0,5) | _OUT(5),
        37, var, buf, 0, 0, size, &spare);

    if (err) {
        errno = os_map_error(err->errnum);
        return NULL;
    }

    return buf;
}

int os_unlink(const char *path) {
    if (!path || *path == '\0') {
        errno = EINVAL;
        return -1;
    }

    const _kernel_oserror *err = _swix(OS_File, _INR(0,1), 6, path); // Delete file
    if (err) {
        errno = os_map_error(err->errnum);
        return -1;
    }
    return 0;
}

int os_rename(const char *oldpath, const char *newpath) {
    if (!oldpath || *oldpath == '\0' || !newpath || *newpath == '\0') {
        errno = EINVAL;
        return -1;
    }

    const _kernel_oserror *err = _swix(OS_FSControl, _INR(0,2), 25, oldpath, newpath);
    if (err) {
        errno = os_map_error(err->errnum);
        return -1;
    }
    return 0;
}

int os_stat(const char *path, struct os_stat_t *st) {
    if (!path || *path == '\0' || !st) {
        errno = EINVAL;
        return -1;
    }

    int r[10];  // Use r[0] to r[6]
    const _kernel_oserror *err = _swix(OS_File,
        _INR(0,1) | _OUTR(0,6),
        23, path,
        &r[0], &r[1], &r[2], &r[3], &r[4], &r[5], &r[6]);

    if (err) {
        errno = os_map_error(err->errnum);
        return -1;
    }

    if (r[0] == 0) { // Object not found
        errno = ENOENT;
        return -1;
    }

    st->st_mode = 0;
    if ((r[6] & 0xF000) == 0x1000)  // &1000 = directory/image
        st->st_mode |= 0x4000;      // S_IFDIR placeholder
    else
        st->st_mode |= 0x8000;      // S_IFREG placeholder

    st->st_size = (unsigned int)r[4];   // Length
    st->st_mtime = (unsigned int)r[5]; // Attributes (often encodes timestamp-ish info)
    return 0;
}

int os_access(const char *pathname, int mode) {
    (void)mode; // RISC OS doesn’t enforce permissions

    if (!pathname || *pathname == '\0') {
        errno = EINVAL;
        return -1;
    }

    int type = 0;
    const _kernel_oserror *err = _swix(OS_File,
        _INR(0,1) | _OUT(0),
        23, pathname, &type);

    if (err) {
        errno = os_map_error(err->errnum);
        return -1;
    }

    if (type == 0) {
        errno = ENOENT;
        return -1;
    }

    return 0;
}

// ----------------------------
// File Descriptor Operations
// ----------------------------

int os_open(const char *path, int flags, int mode) {
    (void)mode;
    if (!path || *path == '\0') {
        errno = EINVAL;
        return -1;
    }

    int access = flags & O_ACCMODE;
    int handle = 0;
    const _kernel_oserror *err = NULL;

    if ((flags & O_CREAT) && access == O_RDWR) {
        // Try open RW first, if fails, create
        err = _swix(OS_Find, _INR(0,1) | _OUT(0), 0xC0, path, &handle);
        if (err) {
            err = _swix(OS_Find, _INR(0,1) | _OUT(0), 0x80, path, &handle); // create
        }
    } else if ((flags & O_CREAT) && access == O_WRONLY) {
        // RISC OS has no "WRONLY" — must use RW
        err = _swix(OS_Find, _INR(0,1) | _OUT(0), 0x80, path, &handle);
    } else if (access == O_RDWR) {
        err = _swix(OS_Find, _INR(0,1) | _OUT(0), 0xC0, path, &handle);
    } else if (access == O_RDONLY) {
        err = _swix(OS_Find, _INR(0,1) | _OUT(0), 0x40, path, &handle);
    } else {
        errno = EINVAL;
        return -1;
    }

    if (err) {
        errno = os_map_error(err->errnum);
        return -1;
    }

    return handle;
}

int os_close(int fd) {
    if (fd < 0) {
        errno = EBADF;
        return -1;
    }

    const _kernel_oserror *err = _swix(OS_Find, _INR(0,1), 0, fd); // Close file
    if (err) {
        errno = os_map_error(err->errnum);
        return -1;
    }
    return 0;
}

int os_read(int fd, void *buf, size_t count) {
    if (fd < 0 || !buf || count == 0) {
        errno = EINVAL;
        return -1;
    }

    int bytes_read = 0;
    const _kernel_oserror *err = _swix(OS_GBPB, _INR(0,3) | _OUT(4),
                                 3, fd, buf, count, &bytes_read);
    if (err) {
        errno = os_map_error(err->errnum);
        return -1;
    }
    return bytes_read;
}

int os_write(int fd, const void *buf, size_t count) {
    if (fd < 0 || !buf || count == 0) {
        errno = EINVAL;
        return -1;
    }

    int not_written = 0;
    const _kernel_oserror *err = _swix(OS_GBPB,
        _INR(0,3) | _OUT(3),
        2, fd, (void *)buf, count,
        &not_written);

    if (err) {
        errno = os_map_error(err->errnum);
        return -1;
    }

    return count - not_written;
}



long os_lseek(int fd, long offset, int whence) {
    if (fd < 0) {
        errno = EBADF;
        return -1;
    }

    if (whence != 0 && whence != 1) {
        errno = EINVAL;
        return -1;
    }

    if (whence == 1) {
        int current = 0;
        const _kernel_oserror *err = _swix(OS_Args, _INR(0,1) | _OUT(2), 0, fd, &current);
        if (err) {
            errno = os_map_error(err->errnum);
            return -1;
        }
        offset += current;
    }

    const _kernel_oserror *err = _swix(OS_Args, _INR(0,2), 1, fd, offset);
    if (err) {
        errno = os_map_error(err->errnum);
        return -1;
    }
    return offset;
}

// Rewind directory to beginning
void os_rewinddir(os_dir_t *dirp) {
    if (!dirp) {
        errno = EINVAL;
        return;
    }
    dirp->context = 0;
}

// Return current directory read position (context value)
long os_telldir(os_dir_t *dirp) {
    if (!dirp) {
        errno = EINVAL;
        return -1;
    }
    return dirp->context;
}

// Seek to a saved directory position (context value)
void os_seekdir(os_dir_t *dirp, long loc) {
    if (!dirp || loc < 0) {
        errno = EINVAL;
        return;
    }
    dirp->context = (int)loc;
}

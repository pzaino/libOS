/*
 * libOS - POSIX-like and SWI-safe C Library for RISC OS
 *
 * File: path.c
 * Author: Paolo Fabio Zaino
 * Copyright (c) 1998-2025 by Paolo Fabio Zaino, all rights reserved
 * Distributed under: Mozilla Public License 2.0 (MPL-2.0)
 *
 * Description:
 *   This file is part of libOS, a safe and portable ANSI C99 library that
 *   provides POSIX-style APIs for RISC OS. It wraps RISC OS SWIs with strict
 *   validation and aims to be CLib-independent while enabling safe development
 *   of applications, kernel modules, and system utilities.
 *
 *   This source code is licensed under the terms of the Mozilla Public License
 *   Version 2.0. You may obtain a copy of the license at:
 *   https://www.mozilla.org/MPL/2.0/
 *
 *   SPDX-License-Identifier: MPL-2.0
 */

/* path.c - Path manipulation helpers for RISC OS (libOS) */

#include "common.h"
#include "path.h"

#include <string.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>

int os_realpath(const char *in, char *out, size_t size) {
    if (!in || !out || size == 0) {
        errno = EINVAL;
        return -1;
    }

    int spare = 0;
    out[0] = '\0';
    const _kernel_oserror *err = _swix(OS_FSControl,
        _INR(0,5) | _OUT(5),
        37, in, out, 0, 0, size, &spare);

    if (err) {
        errno = os_map_error(err->errnum);
        return -1;
    }

    if ((int)size - spare <= 0) {
        errno = ENAMETOOLONG;
        return -1;
    }

    return 0;
}

int os_path_is_absolute(const char *path) {
    return (path && path[0] == '$');
}

char *os_path_join(const char *a, const char *b, char *out, size_t maxlen) {
    if (!a || !b || !out || maxlen == 0) {
        errno = EINVAL;
        return NULL;
    }

    int need_sep = (a[0] != '\0' && a[strlen(a) - 1] != '.');

    int written = snprintf(out, maxlen, "%s%s%s", a, need_sep ? "." : "", b);
    if (written < 0 || (size_t)written >= maxlen) {
        errno = ENAMETOOLONG;
        return NULL;
    }

    return out;
}

const char *os_path_basename(const char *path) {
    if (!path) {
        errno = EINVAL;
        return NULL;
    }

    const char *last = strrchr(path, '.');
    return last ? last + 1 : path;
}

char *os_path_dirname(const char *path, char *out, size_t maxlen) {
    if (!path || !out || maxlen == 0) {
        errno = EINVAL;
        return NULL;
    }

    const char *last = strrchr(path, '.');
    if (!last) {
        if (maxlen < 2) {
            errno = ENAMETOOLONG;
            return NULL;
        }
        strcpy(out, ".");
        return out;
    }

    size_t len = (size_t)(last - path);
    if (len >= maxlen) {
        errno = ENAMETOOLONG;
        return NULL;
    }

    memcpy(out, path, len);
    out[len] = '\0';
    return out;
}

char *os_path_to_riscos(const char *unix_path, char *out, size_t maxlen) {
    if (!unix_path || !out || maxlen == 0) {
        errno = EINVAL;
        return NULL;
    }

    size_t i = 0;
    if (unix_path[0] == '/') {
        if (maxlen < 3) {
            errno = ENAMETOOLONG;
            return NULL;
        }
        out[i++] = '$';
        out[i++] = '.';
        unix_path++;
    }

    for (; i < maxlen - 1 && *unix_path; ++unix_path) {
        out[i++] = (*unix_path == '/') ? '.' : *unix_path;
    }

    if (*unix_path != '\0') {
        errno = ENAMETOOLONG;
        return NULL;
    }

    out[i] = '\0';
    return out;
}

char *os_path_to_unix(const char *riscos_path, char *out, size_t maxlen) {
    if (!riscos_path || !out || maxlen == 0) {
        errno = EINVAL;
        return NULL;
    }

    size_t i = 0;
    if (riscos_path[0] == '$' && riscos_path[1] == '.') {
        if (maxlen < 2) {
            errno = ENAMETOOLONG;
            return NULL;
        }
        out[i++] = '/';
        riscos_path += 2;
    }

    for (; i < maxlen - 1 && *riscos_path; ++riscos_path) {
        out[i++] = (*riscos_path == '.') ? '/' : *riscos_path;
    }

    if (*riscos_path != '\0') {
        errno = ENAMETOOLONG;
        return NULL;
    }

    out[i] = '\0';
    return out;
}
